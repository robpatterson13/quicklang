//
//  ASTLinearize.swift
//  quicklang
//
//  Created by Rob Patterson on 11/16/25.
//

import Foundation

/// Rewrites expressions into a linearized, evaluation-order-friendly AST form.
///
/// ``ASTLinearize`` is an ``ASTUpwardTransformer`` that preserves semantics while
/// introducing intermediate bindings where needed so that later phases can assume
/// a simple, statement-like evaluation order (e.g., left-to-right for binary ops,
/// arguments before function application).
///
/// Strategy:
/// - Children are transformed first to gather any required temporaries.
/// - The current node may be reconstructed using transformed children.
/// - If the node yields a value (e.g., an operation or application), a new temporary
///   binding (``LetDefinition``) is introduced for that value, and the resulting node
///   is returned alongside the temporaries that must precede it.
///
/// - Important: This pass only reshapes evaluation order. It does not perform
///   type checking or symbol resolution; see ``Typechecker`` and ``SymbolResolve``.
///
/// - SeeAlso: ``ASTUpwardTransformer``, ``DefinitionNode``, ``LetDefinition``
class ASTLinearize: SemaPass, ASTUpwardTransformer {
    
    /// Entry point for this pass.
    ///
    /// Implementations should linearize the program and emit diagnostics (if any)
    /// through the provided ``CompilerErrorManager``. This stub ensures conformance
    /// to ``SemaPass``.
    ///
    /// - Parameter reportingTo: The compilerâ€™s error manager for diagnostics.
    func begin(reportingTo: CompilerErrorManager) {
        context.tree = linearize(context.tree)
    }
    
    /// Shared semantic context used by the compiler pipeline.
    ///
    /// Currently unused by this pass, but available for integration with other phases.
    let context: ASTContext
    
    /// Creates a linearization pass bound to the shared semantic context.
    ///
    /// - Parameter context: The shared ``ASTContext``.
    init(context: ASTContext) {
        self.context = context
    }
    
    /// Per-visit payload returned upward to parents.
    ///
    /// For linearization, each node returns the sequence of ``DefinitionNode`` values
    /// (temporary bindings) that must appear before the transformed node in the output.
    typealias TransformerInfo = [any DefinitionNode]
    
    // MARK: - Expressions
    
    /// No-op for identifier references; identifiers are already linear.
    ///
    /// - Parameters:
    ///   - expression: The ``IdentifierExpression`` to visit.
    ///   - finished: Upward-only completion callback receiving the (unchanged) expression
    ///     and an empty list of preceding bindings.
    func visitIdentifierExpression(
        _ expression: IdentifierExpression,
        _ finished: @escaping OnTransformEnd<IdentifierExpression>
    ) {
        finished(expression, [])
    }
    
    /// No-op for boolean literals; literals are already linear.
    ///
    /// - Parameters:
    ///   - expression: The ``BooleanExpression`` to visit.
    ///   - finished: Upward-only completion callback with the (unchanged) expression
    ///     and an empty list of preceding bindings.
    func visitBooleanExpression(
        _ expression: BooleanExpression,
        _ finished: @escaping OnTransformEnd<BooleanExpression>
    ) {
        finished(expression, [])
    }
    
    /// No-op for numeric literals; literals are already linear.
    ///
    /// - Parameters:
    ///   - expression: The ``NumberExpression`` to visit.
    ///   - finished: Upward-only completion callback with the (unchanged) expression
    ///     and an empty list of preceding bindings.
    func visitNumberExpression(
        _ expression: NumberExpression,
        _ finished: @escaping OnTransformEnd<NumberExpression>
    ) {
        finished(expression, [])
    }
    
    /// Linearizes the operand and introduces a binding for the unary operation result.
    ///
    /// Discussion:
    /// 1. Linearize the operand first and collect its preceding bindings.
    /// 2. Rebuild the unary operation with the transformed operand.
    /// 3. Synthesize a fresh temporary name and emit a ``LetDefinition`` that binds the result.
    /// 4. Return the rebuilt operation along with the accumulated preceding bindings
    ///    (including the new result binding).
    ///
    /// - Parameters:
    ///   - operation: The ``UnaryOperation`` to visit.
    ///   - finished: Upward-only completion callback with the transformed operation and
    ///     the list of preceding bindings.
    ///
    /// - Important: The synthesized name is generated by ``genSym(root:id:)`` and is stable
    ///   per node identity.
    func visitUnaryOperation(
        _ operation: UnaryOperation,
        _ finished: @escaping OnTransformEnd<UnaryOperation>
    ) {
        var newBindings: [any DefinitionNode] = []
        var newExpr: (any ExpressionNode)? = nil
        operation.expression.acceptUpwardTransformer(self) { newExpression, bindings in
            newBindings.append(contentsOf: bindings)
            newExpr = newExpression
        }
        
        guard let operand = newExpr else {
            // Should not happen: child must synchronously invoke callback
            finished(operation, newBindings)
            return
        }
        
        let newName = genSym(root: "unary_op", id: operation.id)
        let newOperation = UnaryOperation(op: operation.op, expression: operand)
        let newType = context.getType(of: newOperation)
        let newBinding = LetDefinition(name: newName, type: newType, expression: newOperation)
        newBindings.append(newBinding)
        
        finished(newOperation, newBindings)
    }
    
    /// Linearizes both operands and introduces a binding for the binary operation result.
    ///
    /// Discussion:
    /// 1. Linearize `lhs` then `rhs`, preserving left-to-right evaluation and collecting
    ///    their preceding bindings in order.
    /// 2. Rebuild the binary operation with transformed operands.
    /// 3. Synthesize a fresh temporary name and emit a ``LetDefinition`` for the result.
    /// 4. Return the rebuilt operation along with the accumulated bindings.
    ///
    /// - Parameters:
    ///   - operation: The ``BinaryOperation`` to visit.
    ///   - finished: Upward-only completion callback with the transformed operation and
    ///     the list of preceding bindings.
    func visitBinaryOperation(
        _ operation: BinaryOperation,
        _ finished: @escaping OnTransformEnd<BinaryOperation>
    ) {
        var newBindings: [any DefinitionNode] = []
        
        var newLhsExpr: (any ExpressionNode)? = nil
        operation.lhs.acceptUpwardTransformer(self) { newLhs, bindings in
            newBindings.append(contentsOf: bindings)
            newLhsExpr = newLhs
        }
        var newRhsExpr: (any ExpressionNode)? = nil
        operation.rhs.acceptUpwardTransformer(self) { newRhs, bindings in
            newBindings.append(contentsOf: bindings)
            newRhsExpr = newRhs
        }
        
        guard let lhs = newLhsExpr, let rhs = newRhsExpr else {
            finished(operation, newBindings)
            return
        }
        
        let newName = genSym(root: "binary_op", id: operation.id)
        let newOperation = BinaryOperation(op: operation.op, lhs: lhs, rhs: rhs)
        let newType = context.getType(of: newOperation)
        let newBinding = LetDefinition(name: newName, type: newType, expression: newOperation)
        newBindings.append(newBinding)
        
        finished(newOperation, newBindings)
    }
    
    // MARK: - Definitions
    
    /// Linearizes the bound expression and preserves the `let` definition shape.
    ///
    /// Any temporaries introduced by the initializer are emitted before the definition.
    ///
    /// - Parameters:
    ///   - definition: The ``LetDefinition`` to visit.
    ///   - finished: Upward-only completion callback with the transformed definition and
    ///     the list of preceding bindings.
    func visitLetDefinition(
        _ definition: LetDefinition,
        _ finished: @escaping OnTransformEnd<LetDefinition>
    ) {
        var newBindings: [any DefinitionNode] = []
        var newBoundExpr: (any ExpressionNode)? = nil
        definition.expression.acceptUpwardTransformer(self) { newExpression, bindings in
            newBindings.append(contentsOf: bindings)
            newBoundExpr = newExpression
        }
        
        guard let bound = newBoundExpr else {
            finished(definition, newBindings)
            return
        }
        
        let newType = context.getType(of: bound)
        let newDefinition = LetDefinition(name: definition.name, type: newType, expression: bound)
        finished(newDefinition, newBindings)
    }
    
    /// Linearizes the bound expression and preserves the `var` definition shape.
    ///
    /// Any temporaries introduced by the initializer are emitted before the definition.
    ///
    /// - Parameters:
    ///   - definition: The ``VarDefinition`` to visit.
    ///   - finished: Upward-only completion callback with the transformed definition and
    ///     the list of preceding bindings.
    func visitVarDefinition(
        _ definition: VarDefinition,
        _ finished: @escaping OnTransformEnd<VarDefinition>
    ) {
        var newBindings: [any DefinitionNode] = []
        var newBoundExpr: (any ExpressionNode)? = nil
        definition.expression.acceptUpwardTransformer(self) { newExpression, bindings in
            newBindings.append(contentsOf: bindings)
            newBoundExpr = newExpression
        }
        
        guard let bound = newBoundExpr else {
            finished(definition, newBindings)
            return
        }
        
        let newType = context.getType(of: bound)
        let newDefinition = VarDefinition(name: definition.name, type: newType, expression: bound)
        finished(newDefinition, newBindings)
    }
    
    /// Linearizes a function body while preserving the function signature.
    ///
    /// The body is rewritten into a sequence of block-level nodes that reflect a
    /// linearized evaluation order. The function name, return type, and parameters
    /// are left unchanged.
    ///
    /// - Parameters:
    ///   - definition: The ``FuncDefinition`` to visit.
    ///   - finished: Upward-only completion callback with the transformed function and
    ///     no preceding bindings (functions introduce no temporaries at the declaration boundary).
    func visitFuncDefinition(
        _ definition: FuncDefinition,
        _ finished: @escaping OnTransformEnd<FuncDefinition>
    ) {
        let newBody = linearizeBlock(definition.body)
        let newFuncDef = FuncDefinition(
            name: definition.name,
            type: definition.type,
            parameters: definition.parameters,
            body: newBody
        )
        
        finished(newFuncDef, [])
    }
    
    /// Linearizes each argument and introduces a binding for the call result.
    ///
    /// Discussion:
    /// 1. Linearize arguments from left to right, collecting their temporaries in order.
    /// 2. Rebuild the call with transformed arguments.
    /// 3. Synthesize a fresh temporary name and emit a ``LetDefinition`` that binds the result.
    ///
    /// - Parameters:
    ///   - expression: The ``FuncApplication`` to visit.
    ///   - finished: Upward-only completion callback with the transformed application and
    ///     the list of preceding bindings.
    func visitFuncApplication(
        _ expression: FuncApplication,
        _ finished: @escaping OnTransformEnd<FuncApplication>
    ) {
        var bindings = [any DefinitionNode]()
        var args = [any ExpressionNode]()
        expression.arguments.forEach { arg in
            arg.acceptUpwardTransformer(self) { newArg, newBindings in
                bindings.append(contentsOf: newBindings)
                args.append(newArg)
            }
        }
        
        let newName = genSym(root: "func_app", id: expression.id)
        let newExpr = FuncApplication(name: expression.name, arguments: args)
        let newType = context.getType(of: newExpr)
        let newBinding = LetDefinition(name: newName, type: newType, expression: newExpr)
        bindings.append(newBinding)
        
        finished(newExpr, bindings)
    }
    
    /// Linearizes the condition and transforms both branches.
    ///
    /// Temporaries for the condition are emitted prior to the `if` statement. Branches
    /// are each linearized independently; branch-local temporaries remain in-branch.
    ///
    /// - Parameters:
    ///   - statement: The ``IfStatement`` to visit.
    ///   - finished: Upward-only completion callback with the transformed statement and
    ///     the list of condition temporaries that must precede it.
    func visitIfStatement(
        _ statement: IfStatement,
        _ finished: @escaping OnTransformEnd<IfStatement>
    ) {
        var bindings = [any DefinitionNode]()
        var cond: (any ExpressionNode)? = nil
        statement.condition.acceptUpwardTransformer(self) { newCond, newBindings in
            cond = newCond
            bindings.append(contentsOf: newBindings)
        }
        
        guard let condition = cond else {
            finished(statement, bindings)
            return
        }
        
        let newThenBranch = linearizeBlock(statement.thenBranch)
        var newElseBranch: [any BlockLevelNode]? = nil
        if let elseBranch = statement.elseBranch {
            newElseBranch = linearizeBlock(elseBranch)
        }
        
        let newIfStatement = IfStatement(condition: condition, thenBranch: newThenBranch, elseBranch: newElseBranch)
        finished(newIfStatement, bindings)
    }
    
    /// Linearizes the returned expression and preserves the return statement.
    ///
    /// Any temporaries introduced by the return value are emitted before the `return`.
    ///
    /// - Parameters:
    ///   - statement: The ``ReturnStatement`` to visit.
    ///   - finished: Upward-only completion callback with the transformed statement and
    ///     the list of preceding bindings.
    func visitReturnStatement(
        _ statement: ReturnStatement,
        _ finished: @escaping OnTransformEnd<ReturnStatement>
    ) {
        // the only thing to worry about here is the returned expression;
        // we get the new return value (if necessary) and any new bindings
        // that the return expression introduced
        var newBindings: [any DefinitionNode] = []
        var newReturn: (any ExpressionNode)? = nil
        statement.expression.acceptUpwardTransformer(self) { newExpression, bindings in
            newBindings.append(contentsOf: bindings)
            newReturn = newExpression
        }
        
        guard let ret = newReturn else {
            finished(statement, newBindings)
            return
        }
        
        let newStatement = ReturnStatement(expression: ret)
        finished(newStatement, newBindings)
    }
    
    // MARK: - Block and Program Helpers
    
    /// Rewrites a block into a flattened list of linearized nodes.
    ///
    /// Each block-level node contributes its own required temporaries, followed by the
    /// transformed node itself.
    ///
    /// - Parameter block: The sequence of ``BlockLevelNode`` values to linearize.
    /// - Returns: A new sequence with all required temporaries placed before each transformed node.
    private func linearizeBlock(_ block: [any BlockLevelNode]) -> [any BlockLevelNode] {
        var newBlock = [any BlockLevelNode]()
        
        block.forEach { node in
            node.acceptUpwardTransformer(self) { newNode, newBindings in
                newBlock.append(contentsOf: newBindings)
                newBlock.append(newNode)
            }
        }
        
        return newBlock
    }
    
    /// Entry point to linearize a full program.
    ///
    /// Produces a new ``TopLevel`` where each top-level section has been transformed and
    /// any required temporaries are placed ahead of the transformed node.
    ///
    /// - Parameter ast: The original top-level AST.
    /// - Returns: A new ``TopLevel`` with linearized sections.
    func linearize(_ ast: TopLevel) -> TopLevel {
        let sections = ast.sections
        var transformedSections: [any TopLevelNode] = []
        
        sections.forEach { section in
            section.acceptUpwardTransformer(self) { transformed, bindings in
                transformedSections.append(contentsOf: bindings)
                transformedSections.append(transformed)
            }
        }
        
        return TopLevel(sections: transformedSections)
    }
    
    /// Generates a stable, unique temporary name for synthesized bindings.
    ///
    /// - Parameters:
    ///   - root: A human-readable root used in the synthesized name (e.g., "binary_op").
    ///   - id: The node identity used to ensure stability and uniqueness.
    /// - Returns: A unique symbol name suitable for a temporary ``LetDefinition``.
    private func genSym(root: String, id: UUID) -> String {
        return root + "$" + id.uuidString
    }
}
